(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[188],{684:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/coding/graph/adjacency-map-graph",function(){return t(8139)}])},6724:function(e,n,t){"use strict";t.d(n,{Z:function(){return c}});var r=t(5893),a=t(5988),i=t.n(a),o=(t(8658),t(7829)),s=t.n(o),d=t(4679),g=t(6151),l=t(5604);function c(e){var n,t=null===e||void 0===e||null===(n=e.route)||void 0===n?void 0:n.replace(/\//g," ").trim();return s()(e,{github:"",docsRepositoryBase:"https://github.com/dryleaf/dryleaf.github.io/blob/master",logo:(0,r.jsx)(d.Z,{isToggleDisabled:!0}),head:(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("title",{children:["Josimar Lopes's blog | ",t.replace(/ /g,",")]}),(0,r.jsx)("meta",{name:"description",content:"Josimar Lopes's blog | "+t.replace(/ /g,",")})]}),footerText:(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(g.Z,{}),(0,r.jsx)(l.Z,{}),(0,r.jsx)(i(),{id:"3ce510cfc0eef959",children:".sticky-bottom{position:fixed!important}\n#responsive_overlay{margin:0!important}"})]}),footerEditLink:""})}},8139:function(e,n,t){"use strict";t.r(n);t(7294);var r=t(3905),a=t(6724),i=t(3805);t(5675),t(1127);function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=function(e){return(0,i.withSSG)((0,a.Z)({filename:"adjacency-map-graph.mdx",route:"/blog/coding/graph/adjacency-map-graph",meta:{},pageMap:[{name:"blog",children:[{name:"coding",children:[{name:"graph",children:[{name:"adjacency-map-graph",route:"/blog/coding/graph/adjacency-map-graph"},{name:"meta.json",meta:{"adjacency-map-graph":"Adjacency map graph"}}],route:"/blog/coding/graph"},{name:"meta.json",meta:{graph:"Graph","string-manipulation":"String Manipulation"}}],route:"/blog/coding"},{name:"index",route:"/blog"},{name:"life",children:[{name:"bucket-list",children:[{name:"index",route:"/blog/life/bucket-list"},{name:"meta.json",meta:{}}],route:"/blog/life/bucket-list"},{name:"meta.json",meta:{"bucket-list":"Bucket List","stoic-journal":"Stoic Journal"}},{name:"stoic-journal",children:[{name:"index",route:"/blog/life/stoic-journal"},{name:"meta.json",meta:{index:"1. The art of living"}}],route:"/blog/life/stoic-journal"}],route:"/blog/life"},{name:"meta.json",meta:{index:"Welcome",life:"Life",coding:"Coding",notes:"Notes"}},{name:"notes",children:[{name:"meta.json",meta:{}}],route:"/blog/notes"}],route:"/blog"},{name:"meta.json",meta:{blog:"Josimar Lopes's interests"}}]},null))(e)};function d(e){var n=e.components,t=o(e,["components"]);return(0,r.mdx)(s,Object.assign({components:n},t),(0,r.mdx)("h1",null,"Adjacency Map Graph"),(0,r.mdx)("p",null,"In an Adjacency Map Graph, each vertex also holds the edges incident to it and the arrows exiting it in a separate collection."),(0,r.mdx)("p",null,"An Adjacency Map Graph can be ",(0,r.mdx)("inlineCode",{parentName:"p"},"directed")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"undirected"),", and edges can be ",(0,r.mdx)("inlineCode",{parentName:"p"},"weighted")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"unweighted"),"."),(0,r.mdx)("h2",null,"Graph interface"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{className:"language-java",parentName:"pre"},"/**\n * An interface for a graph structure. A graph can be declared as either directed or undirected.\n * In case of an undirected graph, methods outgoingEdges and incomingEdges return the same collection,\n * and outDegree and inDegree return the same value.\n *\n * Every vertex stores an element of type V (possibly null).\n * Every edge stores an element of type E (possibly null).\n *\n * @author Josimar Lopes\n */\npublic interface Graph<V, E> {\n\n    /** Returns the number of vertices of the graph */\n    int numVertices();\n\n    /** Returns the number of edges of the graph */\n    int numEdges();\n\n    /** Returns the vertices of the graph as an iterable collection */\n    Iterable<Vertex<V>> vertices();\n\n    /** Returns the edges of the graph as an iterable collection */\n    Iterable<Edge<E>> edges();\n\n    /**\n     * Returns the number of edges leaving vertex v.\n     * Note that for an undirected graph, this is the same result\n     * returned by inDegree\n     * @throws IllegalArgumentException if v is not a valid vertex\n     */\n    int outDegree(Vertex<V> v) throws IllegalArgumentException;\n\n    /**\n     * Returns the number of edges for which vertex v is the destination.\n     * Note that for an undirected graph, this is the same result\n     * returned by outDegree\n     * @throws IllegalArgumentException if v is not a valid vertex\n     */\n    int inDegree(Vertex<V> v) throws IllegalArgumentException;\n\n    /**\n     * Returns an iterable collection of edges for which vertex v is the origin.\n     * Note that for an undirected graph, this is the same result\n     * returned by incomingEdges.\n     * @throws IllegalArgumentException if v is not a valid vertex\n     */\n    Iterable<Edge<E>> outgoingEdges(Vertex<V> v) throws IllegalArgumentException;\n\n    /**\n     * Returns an iterable collection of edges for which vertex v is the destination.\n     * Note that for an undirected graph, this is the same result\n     * returned by outgoingEdges.\n     * @throws IllegalArgumentException if v is not a valid vertex\n     */\n    Iterable<Edge<E>> incomingEdges(Vertex<V> v) throws IllegalArgumentException;\n\n    /** Returns the edge from u to v, or null if they are not adjacent. */\n    Edge<E> getEdge(Vertex<V> u, Vertex<V> v) throws IllegalArgumentException;\n\n    /**\n     * Returns the vertices of edge e as an array of length two.\n     * If the graph is directed, the first vertex is the origin, and\n     * the second is the destination.  If the graph is undirected, the\n     * order is arbitrary.\n     */\n    Vertex<V>[] endVertices(Edge<E> e) throws IllegalArgumentException;\n\n    /** Returns the vertex that is opposite vertex v on edge e. */\n    Vertex<V> opposite(Vertex<V> v, Edge<E> e) throws IllegalArgumentException;\n\n    /** Inserts and returns a new vertex with the given element. */\n    Vertex<V> insertVertex(V element);\n\n    /**\n     * Inserts and returns a new edge between vertices u and v, storing given element.\n     *\n     * @throws IllegalArgumentException if u or v are invalid vertices, or if an edge already exists between u and v.\n     */\n    Edge<E> insertEdge(Vertex<V> u, Vertex<V> v, E element) throws IllegalArgumentException;\n\n    /** Removes a vertex and all its incident edges from the graph. */\n    void removeVertex(Vertex<V> v) throws IllegalArgumentException;\n\n    /** Removes an edge from the graph. */\n    void removeEdge(Edge<E> e) throws IllegalArgumentException;\n}\n")),(0,r.mdx)("h2",null,"Vertex interface"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{className:"language-java",parentName:"pre"},"/**\n * A vertex of a graph.\n *\n * @author Josimar Lopes\n */\npublic interface Vertex<V> {\n    /** Returns the element associated with the vertex. */\n    V getElement();\n}\n")),(0,r.mdx)("h2",null,"Edge interface"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{className:"language-java",parentName:"pre"},"/**\n * An edge of a graph.\n *\n * @author Josimar Lopes\n */\npublic interface Edge<E> {\n    /** Returns the element associated with the edge */\n    E getElement();\n}\n")),(0,r.mdx)("h2",null,"Adjacency map graph class"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{className:"language-java",parentName:"pre"},'import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * An implementation for a graph structure using an adjacency map for each vertex.\n *\n * Every vertex stores an element of type V.\n * Every edge stores an element of type E.\n *\n * @author Josimar Lopes\n */\npublic class AdjacencyMapGraph<V, E> implements Graph<V, E> {\n    private boolean isDirected;\n    private List<Vertex<V>> vertices = new LinkedList<>();\n    private List<Edge<E>> edges = new LinkedList<>();\n\n    /**\n     * Constructs an empty graph.\n     * The parameter determines whether this is an undirected or directed graph.\n     */\n    public AdjacencyMapGraph(boolean directed) {\n        isDirected = directed;\n    }\n\n    /** Returns the number of vertices of the graph */\n    public int numVertices() {\n        return vertices.size();\n    }\n\n    /** Returns the vertices of the graph as an iterable collection */\n    public Iterable<Vertex<V>> vertices() { return vertices; }\n\n    /** Returns the number of edges of the graph */\n    public int numEdges() { return edges.size(); }\n\n    /** Returns the edges of the graph as an iterable collection */\n    public Iterable<Edge<E>> edges() { return edges; }\n\n    /**\n     * Returns the number of edges for which vertex v is the origin.\n     * Note that for an undirected graph, this is the same result\n     * returned by inDegree(v).\n     * @throws IllegalArgumentException if v is not a valid vertex\n     */\n    public int outDegree(Vertex<V> v) throws IllegalArgumentException {\n        InnerVertex<V> vert = validate(v);\n        return vert.getOutgoing().size();\n    }\n\n    /**\n     * Returns an iterable collection of edges for which vertex v is the origin.\n     * Note that for an undirected graph, this is the same result\n     * returned by incomingEdges(v).\n     * @throws IllegalArgumentException if v is not a valid vertex\n     */\n    public Iterable<Edge<E>> outgoingEdges(Vertex<V> v) throws IllegalArgumentException {\n        InnerVertex<V> vert = validate(v);\n        return vert.getOutgoing().values();   // edges are the values in the adjacency map\n    }\n\n    /**\n     * Returns the number of edges for which vertex v is the destination.\n     * Note that for an undirected graph, this is the same result\n     * returned by outDegree(v).\n     * @throws IllegalArgumentException if v is not a valid vertex\n     */\n    public int inDegree(Vertex<V> v) throws IllegalArgumentException {\n        InnerVertex<V> vert = validate(v);\n        return vert.getIncoming().size();\n    }\n\n    /**\n     * Returns an iterable collection of edges for which vertex v is the destination.\n     * Note that for an undirected graph, this is the same result\n     * returned by outgoingEdges(v).\n     * @throws IllegalArgumentException if v is not a valid vertex\n     */\n    public Iterable<Edge<E>> incomingEdges(Vertex<V> v) throws IllegalArgumentException {\n        InnerVertex<V> vert = validate(v);\n        return vert.getIncoming().values();   // edges are the values in the adjacency map\n    }\n\n    /** Returns the edge from u to v, or null if they are not adjacent. */\n    public Edge<E> getEdge(Vertex<V> u, Vertex<V> v) throws IllegalArgumentException {\n        InnerVertex<V> origin = validate(u);\n        return origin.getOutgoing().get(v);    // will be null if no edge from u to v\n    }\n\n    /**\n     * Returns the vertices of edge e as an array of length two.\n     * If the graph is directed, the first vertex is the origin, and\n     * the second is the destination.  If the graph is undirected, the\n     * order is arbitrary.\n     */\n    public Vertex<V>[] endVertices(Edge<E> e) throws IllegalArgumentException {\n        InnerEdge<E> edge = validate(e);\n        return edge.getEndpoints();\n    }\n\n    /** Returns the vertex that is opposite vertex v on edge e. */\n    public Vertex<V> opposite(Vertex<V> v, Edge<E> e)\n        throws IllegalArgumentException {\n        InnerEdge<E> edge = validate(e);\n        Vertex<V>[] endpoints = edge.getEndpoints();\n        if (endpoints[0] == v)\n            return endpoints[1];\n        else if (endpoints[1] == v)\n            return endpoints[0];\n        else\n            throw new IllegalArgumentException("v is not incident to this edge");\n    }\n\n    /** Inserts and returns a new vertex with the given element. */\n    public Vertex<V> insertVertex(V element) {\n        InnerVertex<V> v = new InnerVertex<>(element, isDirected);\n        vertices.add(v);\n        int pos = vertices.size() - 1;\n        v.setPosition(vertices.get(pos));\n        return v;\n    }\n\n    /**\n     * Inserts and returns a new edge between vertices u and v, storing given element.\n     *\n     * @throws IllegalArgumentException if u or v are invalid vertices, or if an edge already exists between u and v.\n     */\n    public Edge<E> insertEdge(Vertex<V> u, Vertex<V> v, E element)\n        throws IllegalArgumentException {\n        if (getEdge(u,v) == null) {\n            InnerEdge<E> e = new InnerEdge<>(u, v, element);\n            edges.add(e);\n            int pos = edges.size() - 1;\n            e.setPosition(edges.get(pos));\n            InnerVertex<V> origin = validate(u);\n            InnerVertex<V> dest = validate(v);\n            origin.getOutgoing().put(v, e);\n            dest.getIncoming().put(u, e);\n            return e;\n        } else\n            throw new IllegalArgumentException("Edge from u to v exists");\n    }\n\n    /** Removes a vertex and all its incident edges from the graph. */\n    public void removeVertex(Vertex<V> v) throws IllegalArgumentException {\n        InnerVertex<V> vert = validate(v);\n        // remove all incident edges from the graph\n        for (Edge<E> e : vert.getOutgoing().values())\n            removeEdge(e);\n        for (Edge<E> e : vert.getIncoming().values())\n            removeEdge(e);\n        // remove this vertex from the list of vertices\n        vertices.remove(vert.getPosition());\n        vert.setPosition(null);             // invalidates the vertex\n    }\n\n    @SuppressWarnings({"unchecked"})\n    /** Removes an edge from the graph. */\n    public void removeEdge(Edge<E> e) throws IllegalArgumentException {\n        InnerEdge<E> edge = validate(e);\n        // remove this edge from vertices\' adjacencies\n        InnerVertex<V>[] verts = (InnerVertex<V>[]) edge.getEndpoints();\n        verts[0].getOutgoing().remove(verts[1]);\n        verts[1].getIncoming().remove(verts[0]);\n        // remove this edge from the list of edges\n        edges.remove(edge.getPosition());\n        edge.setPosition(null);             // invalidates the edge\n    }\n\n    @SuppressWarnings({"unchecked"})\n    private InnerVertex<V> validate(Vertex<V> v) {\n        if (!(v instanceof InnerVertex)) throw new IllegalArgumentException("Invalid vertex");\n        InnerVertex<V> vert = (InnerVertex<V>) v;     // safe cast\n        if (!vert.validate(this)) throw new IllegalArgumentException("Invalid vertex");\n        return vert;\n    }\n\n    @SuppressWarnings({"unchecked"})\n    private InnerEdge<E> validate(Edge<E> e) {\n        if (!(e instanceof InnerEdge)) throw new IllegalArgumentException("Invalid edge");\n        InnerEdge<E> edge = (InnerEdge<E>) e;     // safe cast\n        if (!edge.validate(this)) throw new IllegalArgumentException("Invalid edge");\n        return edge;\n    }\n\n    //---------------- nested Vertex class ----------------\n    /** A vertex of an adjacency map graph representation. */\n    private class InnerVertex<V> implements Vertex<V> {\n        private V element;\n        private Vertex<V> pos;\n        private Map<Vertex<V>, Edge<E>> outgoing, incoming;\n\n        /** Constructs a new InnerVertex instance storing the given element. */\n        InnerVertex(V elem, boolean graphIsDirected) {\n            element = elem;\n            outgoing = new HashMap<>();\n            if (graphIsDirected)\n                incoming = new HashMap<>();\n            else\n                incoming = outgoing;    // if undirected, alias outgoing map\n        }\n\n        /** Validates that this vertex instance belongs to the given graph. */\n        public boolean validate(Graph<V,E> graph) {\n            return (AdjacencyMapGraph.this == graph && pos != null);\n        }\n\n        /** Returns the element associated with the vertex. */\n        public V getElement() { return element; }\n\n        /** Stores the position of this vertex within the graph\'s vertex list. */\n        public void setPosition(Vertex<V> p) { pos = p; }\n\n        /** Returns the position of this vertex within the graph\'s vertex list. */\n        public Vertex<V> getPosition() { return pos; }\n\n        /** Returns reference to the underlying map of outgoing edges. */\n        Map<Vertex<V>, Edge<E>> getOutgoing() { return outgoing; }\n\n        /** Returns reference to the underlying map of incoming edges. */\n        public Map<Vertex<V>, Edge<E>> getIncoming() { return incoming; }\n    } //------------ end of InnerVertex class ------------\n\n    //---------------- nested InnerEdge class ----------------\n    /** An edge between two vertices. */\n    private class InnerEdge<E> implements Edge<E> {\n        private E element;\n        private Edge<E> pos;\n        private Vertex<V>[] endpoints;\n\n        /**\n         * Constructs InnerEdge instance from u to v, storing the given element.\n         */\n        @SuppressWarnings({"unchecked"})\n        InnerEdge(Vertex<V> u, Vertex<V> v, E elem) {\n            element = elem;\n            endpoints = (Vertex<V>[]) new Vertex[]{u,v};  // array of length 2\n        }\n\n        /** Returns the element associated with the edge. */\n        public E getElement() { return element; }\n\n        /** Returns reference to the endpoint array. */\n        Vertex<V>[] getEndpoints() { return endpoints; }\n\n        /** Validates that this edge instance belongs to the given graph. */\n        public boolean validate(Graph<V,E> graph) {\n            return AdjacencyMapGraph.this == graph && pos != null;\n        }\n\n        /** Stores the position of this edge within the graph\'s vertex list. */\n        public void setPosition(Edge<E> p) { pos = p; }\n\n        /** Returns the position of this edge within the graph\'s vertex list. */\n        public Edge<E> getPosition() { return pos; }\n    } //------------ end of InnerEdge class ------------\n\n    /**\n     * Returns a string representation of the graph.\n     * This is used only for debugging; do not rely on the string representation.\n     */\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Vertex<V> v : vertices) {\n            sb.append("Vertex ").append(v.getElement()).append("\\n");\n            if (isDirected)\n                sb.append(" [outgoing]");\n            sb.append(" ").append(outDegree(v)).append(" adjacencies:");\n            for (Edge<E> e: outgoingEdges(v))\n                sb.append(String.format(" (%s, %s)", opposite(v,e).getElement(), e.getElement()));\n            sb.append("\\n");\n            if (isDirected) {\n                sb.append(" [incoming]");\n                sb.append(" ").append(inDegree(v)).append(" adjacencies:");\n                for (Edge<E> e: incomingEdges(v))\n                    sb.append(String.format(" (%s, %s)", opposite(v,e).getElement(), e.getElement()));\n                sb.append("\\n");\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * This execution uses the following adjacency list [2,3,1,4,0], you can refer to the example section for details.\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        AdjacencyMapGraph<Character, Integer> adjacencyMapGraph = new AdjacencyMapGraph<>(true);\n        \n        Vertex<Character> u = adjacencyMapGraph.insertVertex(\'u\');\n        Vertex<Character> v = adjacencyMapGraph.insertVertex(\'v\');\n        Vertex<Character> w = adjacencyMapGraph.insertVertex(\'w\');\n        Vertex<Character> x = adjacencyMapGraph.insertVertex(\'x\');\n        Vertex<Character> y = adjacencyMapGraph.insertVertex(\'y\');\n\n        //[u, v, w, x, y]\n        // 0, 1, 2, 3, 4\n        adjacencyMapGraph.insertEdge(u, w, 2);\n        adjacencyMapGraph.insertEdge(v, y, 3);\n        adjacencyMapGraph.insertEdge(w, v, 1);\n        adjacencyMapGraph.insertEdge(w, x, 1);\n\n        System.out.println(adjacencyMapGraph);\n    }\n}\n')),(0,r.mdx)("h3",null,"Example"),"\n",(0,r.mdx)("div",{className:"p-4 border border-gray-200 dark:border-gray-900 rounded mt-6"},(0,r.mdx)("p",{parentName:"div"},(0,r.mdx)("strong",{parentName:"p"},"Input:")),(0,r.mdx)("p",{parentName:"div"},"Given the adjacency list, where the indexes represent the vertices,\nand the values represent the weghts of adjacent vertices between one vertex to another vertex."),(0,r.mdx)("pre",{parentName:"div"},(0,r.mdx)("code",{className:"language-markdown",parentName:"pre"},"Adjacency map list, [2,3,1,4,0], which can be interpreted as:\n- 0\u21922\n- 1\u21924\n- 2\u21921\n- 2\u21923\n- 3\u2192$\n- 4\u2192$\n\nand the indexes of the list can be interpreted as the following vertices:\n- [u, v, w, x, y]\n-  0, 1, 2, 3, 4 \u2190 array indexes\n")),(0,r.mdx)("p",{parentName:"div"},(0,r.mdx)("strong",{parentName:"p"},"Output:")),(0,r.mdx)("pre",{parentName:"div"},(0,r.mdx)("code",{className:"language-markdown",parentName:"pre"},"Vertex u\n [outgoing] 1 adjacencies: (w, 2)\n [incoming] 0 adjacencies:\nVertex v\n [outgoing] 1 adjacencies: (y, 3)\n [incoming] 1 adjacencies: (w, 1)\nVertex w\n [outgoing] 2 adjacencies: (x, 1) (v, 1)\n [incoming] 1 adjacencies: (u, 2)\nVertex x\n [outgoing] 0 adjacencies:\n [incoming] 1 adjacencies: (w, 1)\nVertex y\n [outgoing] 0 adjacencies:\n [incoming] 1 adjacencies: (v, 3)\n"))),(0,r.mdx)("h2",null,"Reference"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("a",{href:"https://en.wikipedia.org/wiki/Adjacency_matrix",parentName:"li"},"Adjacency Matrix")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("a",{href:"https://graphie.readthedocs.io/en/latest/Implementations/index.html",parentName:"li"},"Graph Implementations"))))}d.isMDXComponent=!0,n.default=d},1127:function(e,n,t){t(3952)},3952:function(e,n,t){var r,a=(r=t(7294))&&"object"===typeof r&&"default"in r?r.default:r;const i={default:"bg-orange-100 text-orange-800 dark:text-orange-300 dark:bg-orange-200 dark:bg-opacity-10",error:"bg-red-200 text-red-900 dark:text-red-200 dark:bg-red-600 dark:bg-opacity-30",warning:"bg-yellow-200 text-yellow-900 dark:text-yellow-200 dark:bg-yellow-700 dark:bg-opacity-30"};e.exports=({children:e,type:n="default",emoji:t="\ud83d\udca1"})=>a.createElement("div",{className:`${i[n]} flex rounded-lg callout mt-6`},a.createElement("div",{className:"pl-3 pr-2 py-2 select-none text-xl",style:{fontFamily:'"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"'}},t),a.createElement("div",{className:"pr-4 py-2"},e))}},function(e){e.O(0,[171,675,542,341,774,888,179],(function(){return n=684,e(e.s=n);var n}));var n=e.O();_N_E=n}]);